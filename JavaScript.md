# JavaScript

### 2021.04.06

作业太多，qaq，开始课外学习已经十一点多了，受无语子的断电制度“坑害”，电脑没电，六号没有记录，还是七号一早补写的，就离谱，哎~。不过也没啥好记录的，只是看了半个小时的js历史和用途（就离谱！）

### 2021.04.07

* JavaScript基本语法

  > 每个语句以；结束，没有也可以，但最好有
  >
  > 注意符号都是英文的
  >
  > JavaScript对空格、缩进、换行不敏感
  >
  > 关于注释
  >
  > * <!--html注释-->
  > * /\*css注释\*/
  > * /\*javascript多行注释\*/
  > * //JavaScript单行注释

* 弹窗

  > 控制台输出
  >
  > * console.log（） 在控制台输出
  > * console.error（） 在控制台发出错误提示
  > * console.warn（）  在控制台发出警告提示
  >
  > 浏览器自带的原生弹框
  >
  > * alert（...） 弹窗中显示内容
  > * confirm（...） 带有确定和取消按钮的弹框，会相应的返回ture或者false
  > * prompt（...相应问题...） 带输入框的弹框，会返回输入的内容，返回输入的**字符串**

* 网页跳转

  > location.href="要跳转到的网页的网址"

* 变量

  >变量声明时的关键字是var，如果没有，会默认是在全局创建变量
  >
  >声明没有赋值的情况下，会默认赋值为undefined 
  >
  >若未声明，则报错
  >
  >预编译过程会将声明全部提到前面，但是不会将赋值也提到前面
  >
  >变量命名规则
  >
  >* 建议使用驼峰命名法
  >* 必须以$或_或字母开头
  >* 名称不能过长
  >* 不能用关键字和保留字命名
  >* 变量名区分大小写（JavaScript是区分大小写的）
  >
  >变量的数据类型（6种）
  >
  >* 基本数据类型（值类型）
  >
  > * string 字符串
  >
  >   > 双引号或单引号引起来,不可以混用
  >   >
  >   > 双引号里面可以套单引号，但是双不可以直接套双，可以用转义\\\"
  >   >
  >
  > * number 数值
  >
  >   > 包括了整数和浮点数
  >   >
  >   > Number.MAX_VALUE 返回最大值   Number.MIN_VALUE 返回最小值   
  >   >
  >   > 如果使用Number表示的变量超过了最大值，则会返回Infinity。typeof  Infinity返回number
  >   >
  >   > 浮点数的运算（不精确，可能会得到一个不精确的结果）
  >   >
  >   > NaN&isNaN（）函数
  >   >
  >   > * NaN:特殊的数字，表示not a number， 非数值，用来表示一些无意义的计算的结果
  >   > * isNaN()  任何不能被转化（会对内容进行类型转换）成数值的值，都会让这个函数返回ture
  >
  > * boolean 布尔型
  >
  > * null 空值
  >
  >   > 任何值和null运算就相当于和零运算
  >
  > * undefined 未定义
  >
  >* 引用数据类型（引用类型）
  >
  > > 内置对象funtion、array、date、regexp、error等都是属于object类型
  >
  > * object
  >
  >* 输出数据的类型—— typeof运算符
  >
  > > console.log（typeof  变量名）；
  > >
  > > 返回的是小写的字符串
  > >
  > > 特殊！！！：typeof  null返回的是object

### 2021.04.08

* 数据的强制类型转换

  > * 将其他简单类型转换为string
  >
  >   > * 与空字符串相加：变量名或值+“”（利用字符串与任何类型相加都会将其自动转换成字符串后再相加）
  >   > * 变量.toString（）
  >   > * String（变量
  >   
  > * 其他的数据类型转换成数字
  >
  >   > * Number（）函数
  >   >
  >   >   > 字符串——》
  >   >   >
  >   >   > >  “5145”——》5145       “8956vgui”——》NaN      ""和“        ”——》0
  >   >   >
  >   >   > bool值——》
  >   >   >
  >   >   > > false——》0      ture——》1
  >   >   >
  >   >   > null——》
  >   >   >
  >   >   > > 0
  >   >   >
  >   >   > undefined——》
  >   >   >
  >   >   > > NaN
  >   >
  >   > * parseInt(...)    字符串专用，向下取整  
  >   >
  >   >   > 若字符串既有数字又有其他，则若开头是数字，向下取整返回开头的数字，即无小数部分（parseFloat（）解决）
  >   >   >
  >   >   > 若为非字符串，则会自动转换成字符串再在转换
  >
  > * 转换为布尔值
  >
  >   > * 数字——》
  >   >
  >   >   > 除0和NaN都是true,负数也是true
  >   >
  >   > * 字符串——》
  >   >
  >   >   > 除了空字符串都是true
  >   >
  >   > * null和undefined
  >   >
  >   >   > false
  >   >
  >   > * object——》
  >   >
  >   >   > true

* 数据的进制转换

  > 带标记(IE等浏览器不支持)
  >
  > > 16：0x         8：0          2：0b
  >
  > parseInt（要被转换的**数字**，要转到的进制数）

* 运算符

  > 算术运算符
  >
  > > \+       \--       \*        /         %        ()优先级
  > >
  > > 非number类型的进行运算，会先自动转为number类型（任何值做    \--    \*      /  都会自动转成数字）
  > >
  > > 任何与NaN运算，结果还是NaN
  > >
  > > 与字符串进行**加法**运算，先转为字符串，后拼接
  >
  > 乘方
  >
  > > Math.pow(a,b)     a^b
  >
  > 开方
  >
  > > 开平方
  > >
  > > Math.sqrt（...）
  >
  > 自增自减
  >
  > > a++     ++a       a--       --a
  >
  > 逻辑运算符（用于布尔值，返回的也是布尔值）
  >
  > > 或||     且&&      非！
  > >
  > > 若非布尔型进行或与运算（先转换为布尔型再运算但返回的是原值）
  > >
  > > > * 或
  > > >
  > > >   > 第一个值为true——》返回第一个值；第一个值为false——》返回第二个值
  > > >
  > > > * 与
  > > >
  > > >   > 第一个值为true——》返回第二个值；第一个值为false——》返回第一个值
  >
  > 赋值运算符
  >
  > > +=    -=      /=   *=    %=  
  >
  > 关系运算符（返回布尔型）
  >
  > > \>        \<       \>=        \<=       ===        ==(会进行隐式转换)       !=（不等于，==的反面）        !==（不全等于,===的反面）
  > >
  > > 非数值的比较
  > >
  > > > * 转换为数字后进行比较，**任何**值和NaN作比较都是false
  > > > * 两个字符串作比较（无论是否能转换成数字）：一位一位地转换成Unicode编码比较
  > >
  > > NaN不与任何值相等，包括自身，可以用isNaN（）函数来判断是否是NaN
  >
  > 三元运算符（又“条件运算符”）
  >
  > > 条件？条件成立时返回的值或要执行的语句：条件不成立时返回的值或要执行的语句

### 2021.04.09-12

近期较忙，未学习

### 2021.04.13

学习git，建立云笔记

### 2021.04.17-19

* 函数

  > 是对象，用typeof返回function
  >
  > * 创建函数
  >
  >   > * 函数声明
  >   >
  >   >   ```
  >   >   funtion 函数名 （形参1，...，形参n）{
  >   >   语句...
  >   >   }
  >   >   ```
  >   >
  >   > * 函数表达式
  >   >
  >   >   ```
  >   >   var 函数名 =funtion （形参1，....，形参n）{
  >   >   语句...
  >   >   }
  >   >   ```
  >   >
  >   >   函数名不带括号，就是代表整个函数对象，获取对象；带括号，是函数调用，获取返回值。
  >   >
  >   >   创建函数时不执行函数的内容，调用函数时才执行。
  >   >
  >   >   以上两者的区别在于，前者是整个函数的提升，后者只是声明的提升（var  函数名）
  >
  > * 参数
  >
  >   > * 实参的类型
  >   >
  >   >   > 可以是任何的数据类型，调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。
  >   >
  >   > * 实参的数量
  >   >
  >   >   > javascript不会对实际传入的参数进行检查，可以传值也可以不传值，也可以任意传多个值，少的为undefined，多的不赋值
  >   >   >
  >   >   > arguments：可以通过arguments获取所有的实际传入的参数，也就是储存在数组中
  >
  > * 函数的返回值
  >
  >   > * return后的值将会作为函数的执行结果返回，可以定义一个变量，来**接收**该结果，无接收无输出，就相当于return了个寂寞
  >   > * 在函数中return后的语句都不会执行，函数在执行完return语句后停止并立即退出
  >   > * 如果return语句后面不跟任何值，就相当于返回一个undefined，不写return，也会返回undefined
  >   > * 返回值可以是任意的数据类型，可以是对象，也可以是函数
  >
  > * 函数加载问题
  >
  >   > js加载时，只加载函数名，不加载函数体，所以要想使用**内部**的成员变量，需要**调用**函数 
  >
  > * 立即执行函数
  >
  >   > ```
  >   > //现有匿名函数
  >   > funtion(a,b){
  >   >    console.log("a="+a);
  >   >    console.log("b="+b);
  >   > };
  >   > //立即执行函数如下
  >   > (funtion(a,b){
  >   >    console.log("a="+a);
  >   >    console.log("b="+b);
  >   > })(113,456);//也可以将（）换成！
  >   > ```
  >   >
  >   > 立即执行函数：函数定义完后，立即被调用的一种函数
  >   >
  >   > 立即调用函数往往只会执行一次，因为没有变量保存它，执行完后，就找不到它了

* 作用域

  > * 全局作用域
  >
  >   > 全局作用域在页面打开时创建，在页面关闭时销毁
  >   >
  >   > * window
  >   >
  >   >   > 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建，可以直接使用。
  >   >   >
  >   >   > 在全局作用域中，
  >   >   >
  >   >   > * 创建的变量都会作为window对象的属性保存
  >   >   > * 创建的函数都会作为window对象的方法保存
  >   >
  >   > 变量的声明提前（变量提升）
  >   >
  >   > > 使用var关键字声明的变量，会在所有代码执行之前被声明（但不会赋值）；但如果。声明变量时不是用var关键字，则变量不会被声明提前。
  >   >
  >   > 函数中没有var声明的变量和在函数外出现的变量都是全局变量。
  >
  > * 函数作用域
  >
  >   > 当在函数作用域操作一个变量时，它会在自身作用域中寻找，如果有就直接用，如果没有，就向上一级作用域中寻找，直到全局作用域，如还无，报错
  >   >
  >   > 若在函数中想访问一个在全局和函数都定义了的变量，可以使用window对象
  >   >
  >   > 函数内也有变量提升
  >   >
  >   > 执行期上下文
  >   >
  >   > >  当函数执行时，会创建一个执行期上下文的内部对象。每调用 一次函数，就会创建一个新的上下文对象，它们之间相互独立，执行完毕后销毁。
  >   > >
  >   > > 但当函数内部的变量被另外一个函数所引用，那么这个函数的变量将不会在执行完毕后销毁（闭包）。